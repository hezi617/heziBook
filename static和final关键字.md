## **一、static关键字的四种用法**

### **1.修饰成员变量**

**static最常用的功能就是修饰类的属性和方法，让他们成为类的成员属性和方法，我们通常将用static修饰的成员称为类成员或者静态成员，这是相对于对象的属性和方法来说的。**

**2.修饰成员方法**

**static修饰成员方法。相比于修饰成员属性，修饰成员方法对于数据的存储上面并没有多大的变化，因为我们从上面可以看出，方法本来就是存放在类的定义当中的。static修饰成员方法大的作用，就是可以使用"类名.方法 名"的方式操作方法，避免了先要new出对象的繁琐和资源消耗，我们可能会经常在帮助类中看到它的使用。它也有使用的局限，一个static修饰的类中，不能使用非static修饰的成员变量和方法，**

### **3.静态块**

**当我们初始化static修饰的成员时，可以 将他们统一放在一个以static开始，用花括号包裹起来的块状语句中。**

 当我们new一个Person对象时，static修饰的成员变量首先被初始化，随后是普通成员，后调用Person类的构造方法完成 初始化。也就是说，**在创建对象时，static修饰的成员会首先被初始化，如果有多个static修饰的成 员，那么会按照他们的先后位置进行初始化。当我们第一次去使用一个类时，就会触发该类 的成员初始化。第二个是当我们使用了类方法，完成类的成员的初始化后，再new该类的对象时，static修饰的类成员没有再次初始化，这说明，static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。**

### **4.静态导包**

```java
/* PrintHelper.java文件 */ 
package com.dotgua.study; 
public class PrintHelper { 
 	public static void print(Object o){ 
    	System.out.println(o);
    } 
}

/* App.java文件 */  
import static com.dotgua.study.PrintHelper.*; 
public class App  { 
	public static void main( String[] args ) {
    	print("Hello World!");
    }     
    /**Output      
     * Hello World!      
     */ 
} 
```
**将PrintHelper类导入，这里在导入时，我们使用了static关键字，而且在引入类的后还加上了“.\*”，它的作用 就是将PrintHelper类中的所有类方法直接导入。不同于非static导入，采用static导入包后，在不与当前类的方法名冲突 的情况下，无需使用“类名.方法名”的方法去调用类方法了，直接可以采用"方法名"去调用类方法，就好像是该类自己的方法一样使用即可。** 

### ***总结：***

**static关键字主要有四种用法：**

***1. 用来修饰成员变量，将其变为类的成员，从而实现所有对象对于该成员的共享；***

 ***2. 用来修饰成员方法，将其变为类方法，可以直接使用“类名.方法名”的方式调用，常用于工具类；*** 

***3. 静态块用法，将多个类成员放在一起初始化，使得程序更加规整，其中理解对象的初始化过程非常关键；*** 

***4. 静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。***



## **二、final关键字的四种用法**

### **1.修饰变量**

**在编写程序时，我们经常需要说明一个数据是不可变的，我们成为常量。在Java中，用final关键字修饰的变量，只能进行 一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器，这个数据是不会修改的，那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。不过在针对基本类型和引用类型时，final关键字的效果存在细微差别。**

**final修饰的变量可以不在声明时赋值，即可以先声明，后赋值；**

**final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的。**

**因为final修饰的数据的值是不可改变的，所以我们必须确保在 使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成 员时赋值，另一个是在构造方法中赋值，在这两个地方我们必须给它们赋初始值。**

**注意：同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。**

### **2.修饰方法参数**

**那么如果变量是作为参数传入的，我们怎么保证它的值不会改变呢？在我们编写方法时， 可以在参数前面添加final关键字，它表示在整个方法中，我们不会（实际上是不能）改变参数的值：**

```java
public class FinalTest { 
    /* ... */ 
    public void finalFunc(final int i, final Value value) {
    	// i = 5; 不能改变i的值         
    	// v = new Value(); 不能改变v的值 
    	 value.v = 5; // 可以改变引用对象的值
    }
}
```

### **3.修饰方法**

**第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。**

**这种使用方式主要是从设计的角度考虑，即明确告诉 其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字 还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。**

### **4.修饰类**

**使用final关键字修饰类的作用，那就是用final修饰的类是无法被继承的。**

**final的四种用法，然而，对于第三种和第四种用法，我们却甚少使用。**

从final的设计 来讲，这两种用法甚至可以说是鸡肋，因为对于开发人员来讲，如果我们写的类被继承的越多，就说明我们写的类越有价值。即使是从设计的角度来讲，也没有必要将一个类设计为不可继承的。Java标准库就是一个很好的反例，特别 是Java 1.0/1.1中Vector类被如此广泛的运用，如果所有的方法均未被指定为final的话，它可能会更加有用。如此有用的类，我们很容易想到去继承和重写他们，然而，由于final的作用，导致我们对Vector类的扩展受到了一些阻碍，导致了 Vector并没有完全发挥它应有的全部价值。

### ***总结***

**final关键字主要用法有以下四种：**

***1. 用来修饰变量，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；***

 ***2. 用来修饰方法参数，表示在变量的生存期中它的值不能被改变；***

 ***3. 修饰方法，表示该方法无法被重写；***

 ***4. 修饰类，表示该类无法被继承。***

上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。